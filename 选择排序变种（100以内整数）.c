#include<stdio.h>
#include<float.h>

/*
 * 功能：用“选择最小值+标记为已用（DBL_MAX）”的方式，将数组 nums 的元素按升序拣选到 results。
 * 思路：重复 len_nums 次，每次在 nums 中找当前未被选中的最小值，写入 results[j]，并把该值的位置改为 DBL_MAX。
 * 复杂度：时间 O(n^2)，空间 O(1) 额外（除了 results 输出数组）。
 * 注意：
 * 1) 程序会修改 nums（把已选元素设为 DBL_MAX）。
 * 2) 当 min 初值等于 limit（100）且剩余元素都不小于 100 时，可能导致 min_index 未初始化的风险（见循环内注释）。
 * 3) 标题写“100以内整数”，但数据中包含 81.55（非整数）。
 */

double nums[] =
{
                  64.0, 34.0, 25.0, 12.0, 22.0, 11.0, 90.0, 58.0, 61.0, 20.0,
                  35.0, 65.0, 45.0, 100.0, 17.0, 77.0, 50.0, 2.0, 84.0, 54.0,
                  5.0, 56.0, 27.0, 45.0, 65.0, 83.0, 91.0, 37.0, 64.0, 50.0, 53.0,
                  32.0, 41.0, 59.0, 36.0, 89.0, 57.0, 86.0, 76.0, 34.0, 58.0, 55.0,
                  92.0, 14.0, 62.0, 11.0, 23.0, 78.0, 39.0, 46.0, 95.0, 70.0, 29.0,
                  24.0, 68.0, 79.0, 8.0, 85.0, 3.0, 71.0, 48.0, 52.0, 31.0, 49.0, 21.0,
                  99.0, 13.0, 4.0, 60.0, 19.0, 42.0, 93.0, 47.0, 26.0, 72.0, 38.0, 7.0,
                  12.0, 80.0, 51.0, 10.0, 74.0, 69.0, 25.0, 6.0, 40.0, 88.0, 81.55, 97.0,
                  22.0, 63.0, 30.0, 1.0, 66.0, 15.0, 87.0, 94.0, 75.0, 18.0, 73.0, 98.0, 9.0, 33.0, 16.0
};
double results[100];

int main(void) {
    const double limit = 100L; // 初始“最小值”上界（将寻找 < limit 的元素）；100L 会转换为 double
    unsigned int len_nums = (unsigned)sizeof(nums) / (unsigned)sizeof(nums[0]); // 元素个数
    double min = limit;       // 当前轮次的最小值，起始为 limit
    unsigned int min_index;   // 当前轮次最小值的下标（注意：若本轮未找到比 min 更小的值会未初始化）

    // 外层循环：执行 len_nums 轮，每轮选出一个最小值写入 results[j]
    for (unsigned int j = 0; j < len_nums; j++)           
    {
        // 内层循环：在 nums 中扫描，寻找严格小于 min 的元素作为当前最小
        for (unsigned int i = 0; i < len_nums; i++)
        {
            if (min > nums[i])
            {
                min = nums[i];
                min_index = i; // 记录本轮最小值所在位置
            }
        }

        // 将本轮找到的最小值写入结果数组
        results[j] = min;

        // 把该元素标记为“已使用”，避免下轮再次被选中
        // 风险：如果本轮没有找到比 min 更小的值（例如仅剩 100，而 min 初值也是 100），min_index 未定义
        // 可改进：将 min 初值设为 DBL_MAX，或先假定第一个未被使用的元素为候选最小值，避免未初始化
        nums[min_index] = DBL_MAX;

        // 重置最小值为上界，开始下一轮查找
        min = 100L;
    }

    // 输出结果：升序序列
    for (unsigned int i = 0; i <= len_nums - 1; i++)
    {
        printf("%0f\n", results[i]); // %0f 等价于 %f（宽度为 0 不生效）
    }
    return 0;

                                                                      


}