#include<stdio.h>

/*
 * 程序功能：对数组 "nums" 执行选择排序（升序），在原数组上就地排序并打印结果。
 * 基本思路：
 *   - 外层循环确定当前位置 i；
 *   - 内层循环在未排序区间 [i+1, len_nums-1] 中找到最小元素的下标 min_index；
 *   - 将最小元素与 nums[i] 交换；重复直到数组有序。
 * 复杂度：时间 O(n^2)，空间 O(1)（就地排序）。
 * 特性与注意：
 *   - 排序是“不稳定”的（相等元素的相对次序可能改变）。
 *   - 程序会修改原数组 nums。
 *   - 数据中包含 81.55（非整数），但用 double 排序不受影响。
 */

double nums[] =
{
                  64.0, 34.0, 25.0, 12.0, 22.0, 11.0, 90.0, 58.0, 61.0, 20.0,
                  35.0, 65.0, 45.0, 100.0, 17.0, 77.0, 50.0, 2.0, 84.0, 54.0,
                  5.0, 56.0, 27.0, 45.0, 65.0, 83.0, 91.0, 37.0, 64.0, 50.0, 53.0,
                  32.0, 41.0, 59.0, 36.0, 89.0, 57.0, 86.0, 76.0, 34.0, 58.0, 55.0,
                  92.0, 14.0, 62.0, 11.0, 23.0, 78.0, 39.0, 46.0, 95.0, 70.0, 29.0,
                  24.0, 68.0, 79.0, 8.0, 85.0, 3.0, 71.0, 48.0, 52.0, 31.0, 49.0, 21.0,
                  99.0, 13.0, 4.0, 60.0, 19.0, 42.0, 93.0, 47.0, 26.0, 72.0, 38.0, 7.0,
                  12.0, 80.0, 51.0, 10.0, 74.0, 69.0, 25.0, 6.0, 40.0, 88.0, 81.55, 97.0,
                  22.0, 63.0, 30.0, 1.0, 66.0, 15.0, 87.0, 94.0, 75.0, 18.0, 73.0, 98.0, 9.0, 33.0, 16.0
};

int main(void) {
    unsigned int len_nums = (unsigned int)sizeof(nums) / (unsigned int)sizeof(nums[0]); // 计算元素个数
    double mid_num; // 交换用临时变量，类型与 nums 一致

    // 外层：依次确定每个位置 i 上应放置的最小元素
    for (unsigned int i = 0; i <= (len_nums - 1); i++)
    {
        unsigned int min_index = i; // 当前最小值的下标
        // 内层：在 [i+1, len_nums-1] 范围内寻找最小元素的下标
        for (unsigned int j = (i + 1); j <= (len_nums - 1); j++)
        {
            if (nums[j] < nums[min_index])
            {
                min_index = j;
            }
        }
        // 将最小元素交换到位置 i
        mid_num = nums[i];           // 交换：使用临时变量
        nums[i] = nums[min_index];
        nums[min_index] = mid_num;
    }

    // 输出排序后的结果（升序）
    for (unsigned int i = 0; i <= (len_nums - 1); i++)
    {
        printf("%f\n", nums[i]);
    }
    return 0;
}